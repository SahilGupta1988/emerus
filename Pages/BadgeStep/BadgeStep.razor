@using Emerus.ETM.Admin.Pages
@attribute [Authorize(Roles = "Approver,Requestor")]
@using Microsoft.AspNetCore.Components.Forms
@using System.Linq

<style>
    .required-asterisk {
        color: #dc3545;
        margin-left: .25rem;
    }

    .field-validation {
        color: #dc3545;
        font-size: .875rem;
        margin-top: .25rem;
        display: block;
    }
</style>

<div class="card-section">
    <h5>Badge Request</h5>

    <EditForm EditContext="editContext" OnValidSubmit="OnValidSubmit">
        <DataAnnotationsValidator />
        @* <ValidationSummary class="alert alert-danger" /> *@

        <div class="form-check form-switch mb-2">
            <input class="form-check-input" type="checkbox" id="NeedsBadge" @bind="Model.NeedsBadge" />
            <label class="form-check-label" for="NeedsBadge">Request building access badge</label>
        </div>

        <p class="text-muted small mb-3">
            Toggle to request a physical badge. When disabled, facility and access level are read-only.
        </p>

        <div class="row g-3">
            <div class="col-md-6">
                <label class="form-label" for="PrimaryFacility">Facility</label>
                <input id="PrimaryFacility"
                       class="form-control"
                       placeholder="Primary facility or campus"
                       @bind="Model.PrimaryFacility"
                       disabled="@(Model.NeedsBadge == false)" />
            </div>

            <div class="col-md-6">
                <label class="form-label" for="RequestType">
                    Access Level / Request Type
                    <span class="required-asterisk">*</span>
                </label>

                <InputSelect id="RequestType"
                             class="form-select"
                             @bind-Value="Model.RequestType"
                             disabled="@(Model.NeedsBadge == false)">
                    <option value="">Select access level</option>
                    <option value="Contingent">Contingent</option>
                    <option value="Clinician">Clinician</option>
                    <option value="Vendor">Vendor</option>
                </InputSelect>

                <ValidationMessage For="@(() => Model.RequestType)" class="field-validation" />
            </div>
        </div>
    </EditForm>
</div>

@code {
    // [Parameter]
    // public OnboardingNew.BadgeModel Model { get; set; } = default!;

    private EditContext? editContext;
    private ValidationMessageStore? messageStore;
    private EventHandler<FieldChangedEventArgs>? fieldChangedHandler;

    protected override void OnInitialized()
    {
        if (Model is null)
        {
            Model = new OnboardingNew.BadgeModel();
        }

        editContext = new EditContext(Model);
        messageStore = new ValidationMessageStore(editContext);

        fieldChangedHandler = (_, __) => ValidateModel();
        editContext.OnFieldChanged += fieldChangedHandler;

        ValidateModel();
    }

    private void OnValidSubmit()
    {
        // No-op: actual flow is controlled by parent page
    }

    private void ValidateModel()
    {
        if (editContext is null || messageStore is null) return;

        // Clear messages added by this component's store
        messageStore.Clear();

        // Run registered validators (DataAnnotationsValidator) first so their messages appear.
        // This prevents us adding a duplicate message when the model has attributes like [Required].
        if (editContext.Validate())
        {
            // validators added messages (if any) — we'll respect those and not add duplicates below
        }

        var field = editContext.Field(nameof(Model.RequestType));

        // Add our conditional message only when:
        // - user requests a badge, and
        // - there are no existing validation messages for the field.
        if (Model.NeedsBadge && !editContext.GetValidationMessages(field).Any() && string.IsNullOrWhiteSpace(Model.RequestType))
        {
            messageStore.Add(field, "Access level / request type is required when requesting a badge.");
        }

        // If the badge is not requested, ensure we don't show a validation message for RequestType.
        // Clearing our store above removes our custom messages; if a data-annotation produced a message earlier,
        // re-run validation with the current state (no validators should add a message because needsBadge=false),
        // then notify UI. If you still have attribute-based [Required] on the model you want conditional,
        // consider making that conditional (via IValidatableObject or a custom validator) instead of [Required].
        if (!Model.NeedsBadge)
        {
            // Avoid calling editContext.Validate() here because it may re-add attribute messages.
            // Clearing our own store and notifying the UI removes custom messages immediately.
            // For attribute-driven messages you want to suppress when NeedsBadge==false, move that logic into model validation.
        }

        editContext.NotifyValidationStateChanged();
    }

    public void Dispose()
    {
        if (editContext is not null && fieldChangedHandler is not null)
        {
            editContext.OnFieldChanged -= fieldChangedHandler;
        }
    }
}
